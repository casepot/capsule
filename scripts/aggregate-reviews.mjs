#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';
import Ajv from 'ajv';
import addFormats from 'ajv-formats';

const root = process.cwd();
const schemaPath = path.join(root, 'review', 'report.schema.json');
const reportsDir = path.join(root, 'review', 'reports');
const outSummary = path.join(root, 'review', 'summary.md');
const outGate = path.join(root, 'review', 'gate.txt');

const mustFiles = {
  'claude-code': path.join(reportsDir, 'claude-code.json'),
  'codex-cli': path.join(reportsDir, 'codex-cli.json'),
  'gemini-cli': path.join(reportsDir, 'gemini-cli.json'),
};

// Use draft-07 mode for better compatibility
const ajv = new Ajv({ strict: false, allErrors: true });
addFormats(ajv);

function die(msg) { console.error(msg); process.exit(1); }

const schema = JSON.parse(await fs.readFile(schemaPath, 'utf8'));
const validate = ajv.compile(schema);

const results = [];
const errors = [];

for (const [tool, file] of Object.entries(mustFiles)) {
  try {
    const raw = await fs.readFile(file, 'utf8');
    const json = JSON.parse(raw);
    if (!validate(json)) {
      errors.push(`Schema invalid for ${tool}: ${ajv.errorsText(validate.errors, { separator: '\n- ' })}`);
      continue;
    }
    results.push(json);
  } catch (e) {
    errors.push(`Missing or unreadable report for ${tool}: ${e.message}`);
  }
}

let gate = 'fail';

// Build deterministic aggregate
const byTool = Object.fromEntries(results.map(r => [r.tool, r]));

const allFindings = results.flatMap(r =>
  (r.findings || []).map(f => ({ ...f, _tool: r.tool }))
);

const mustFix = allFindings.filter(f => f.must_fix || f.severity === 'critical' || f.severity === 'high');
const assumptions = results.flatMap(r =>
  (r.assumptions || []).map(a => ({ ...a, _tool: r.tool }))
);

const allReady = results.length === 3
  && results.every(r => r.exit_criteria?.ready_for_pr === true);

if (errors.length === 0 && mustFix.length === 0 && allReady) {
  gate = 'pass';
}

const lines = [];
lines.push(`# Multi‑Model Review Summary`);
lines.push('');
if (errors.length) {
  lines.push('## Validation Errors');
  for (const e of errors) lines.push(`- ${e}`);
  lines.push('');
}
lines.push('## Provider Summaries');
for (const r of results) {
  lines.push(`### ${r.tool} (${r.model})`);
  lines.push(r.summary?.trim() || '_no summary_');
  lines.push('');
}

lines.push('## Must‑fix (union)');
if (mustFix.length === 0) {
  lines.push('- None');
} else {
  for (const f of mustFix) {
    const locus = [f.file, f.lines].filter(Boolean).join(':');
    lines.push(`- [${f.severity}] (${f._tool}) ${f.category} — ${f.message}${locus ? ` — ${locus}` : ''}`);
    if (f.suggestion) lines.push(`  - Suggestion: ${f.suggestion}`);
    if (Array.isArray(f.evidence) && f.evidence.length) {
      lines.push(`  - Evidence: ${f.evidence.join('; ')}`);
    }
  }
}
lines.push('');

lines.push('## Assumptions with uncertainty');
const uncertain = assumptions.filter(a => a.status === 'uncertain');
if (uncertain.length === 0) {
  lines.push('- None');
} else {
  for (const a of uncertain) {
    lines.push(`- (${a._tool}) ${a.text}`);
    if (a.falsification_step) lines.push(`  - Falsify by: ${a.falsification_step}`);
  }
}
lines.push('');

lines.push(`## Gate: **${gate.toUpperCase()}**`);
lines.push('');
lines.push('_This comment was generated by a self‑hosted workflow using subscription/OAuth CLIs only. No API keys were used._');

await fs.writeFile(outSummary, lines.join('\n'));
await fs.writeFile(outGate, gate, 'utf8');

// Exit code mirrors gate (and schema errors)
if (gate === 'pass') process.exit(0);
process.exit(1);