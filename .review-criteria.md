# Capsule Review Criteria

Project-specific review criteria for the Capsule subprocess-isolated Python execution service.

> **IMPORTANT**: We are in a transition phase from ThreadedExecutor to AsyncExecutor + Resonate architecture. Both patterns are acceptable during this transition.

<architecture>
## Architecture Requirements

### Current State (Acceptable During Transition)
- ThreadedExecutor for synchronous code execution
- Direct namespace manipulation
- Basic message protocol without full field population
- Future-based correlation patterns

### Target Architecture (Where We're Going)
- AsyncExecutor with execution mode routing (top-level await, async, blocking I/O, simple sync)
- Promise-based communication preparing for Resonate SDK integration
- Capability-based dependency injection
- Durable namespace management with crash recovery

### Invariants (Must Always Be True)
- Maintain strict separation between protocol, session, subprocess, and API layers
- All background operations must use asyncio.Event - no polling loops
- User code runs in appropriate context (thread for blocking, async for await)
- Single-reader invariant: only one execution per session at a time
- Event-driven patterns only (except hybrid health check baseline)
</architecture>

<namespace-management>
## Namespace Management - CRITICAL

### The Golden Rule
**NEVER replace the namespace dictionary, ALWAYS merge updates**
```python
# ❌ WRONG - Causes KeyError failures
self._namespace = new_namespace

# ✅ CORRECT - Preserves engine internals
self._namespace.update(new_namespace)
```

### Protected Keys
Engine internals that must be preserved:
- `_`, `__`, `___` (last results)
- `_i`, `_ii`, `_iii` (last inputs)
- `Out`, `In` (history)
- `_oh`, `_ih` (IPython compatibility)
- `_exit_code`, `_exception`

### Merge Strategies
- User code: Cannot overwrite engine internals
- Engine code: Can modify internals
- Thread results: Merge with conflict resolution
</namespace-management>

<execution-modes>
## Execution Mode Requirements

### Code Analysis Required
Every execution must analyze code to determine mode:
1. **TOP_LEVEL_AWAIT**: Contains await at module level → AsyncExecutor with PyCF_ALLOW_TOP_LEVEL_AWAIT (0x1000000)
2. **ASYNC_DEF**: Contains async function definitions → AsyncExecutor
3. **BLOCKING_SYNC**: Uses blocking I/O (requests, socket, etc.) → ThreadedExecutor
4. **SIMPLE_SYNC**: Simple synchronous code → Direct execution or ThreadedExecutor

### Async Executor Requirements
- Use compile flag `PyCF_ALLOW_TOP_LEVEL_AWAIT = 0x1000000` for top-level await
- Never use `dont_inherit=True` in compile() - breaks cancellation
- Handle coroutine lifecycle properly (track, close on cleanup)
- Use existing event loop - DO NOT create new loops
</execution-modes>

<event-loop-management>
## Event Loop Management

### Critical Rules
1. **Get or set loop BEFORE creating asyncio objects**
```python
# ✅ CORRECT
loop = asyncio.get_running_loop() or asyncio.new_event_loop()
asyncio.set_event_loop(loop)
event = asyncio.Event()  # Now uses correct loop

# ❌ WRONG
event = asyncio.Event()  # Might bind to wrong loop
loop = asyncio.get_running_loop()  # Too late!
```

2. **All asyncio objects in a session must use the same loop**
3. **ThreadedExecutor must coordinate with main loop via `call_soon_threadsafe`**
</event-loop-management>

<concurrency>
## Concurrency & Threading
- Never hold locks during expensive operations (subprocess creation, I/O)
- Use placeholder reservation pattern for pool operations
- Thread-safe async bridge required for ThreadedExecutor
- Use asyncio.Queue for async producer/consumer patterns
- call_soon_threadsafe for thread-to-async communication
- RLock for namespace access (supports reentrant access)
</concurrency>

<session-management>
## Session Management
- Sessions must track state with proper transitions
- Initial state after startup should be IDLE or READY (fix inconsistency)
- Use async with session._state_lock for state changes
- Always check session.state before operations
- Handle TERMINATED state gracefully
- Session reuse is mandatory - each Session() creates new subprocess
- Event loop must be consistent throughout session lifetime
</session-management>

<message-protocol>
## Message Protocol Requirements

### Required Fields (Must Be Present)
- All messages inherit from BaseMessage with id and timestamp
- ResultMessage MUST include `execution_time` field
- HeartbeatMessage MUST include `memory_usage`, `cpu_percent`, `namespace_size`
- CheckpointMessage MUST include all data fields when used

### Protocol Rules
- Use MessageType enum for type field
- Messages serialized with MessagePack (fallback to JSON)
- 4-byte length prefix for framing
- Correlation IDs must be maintained (e.g., InputMessage.id → InputResponseMessage.input_id)

### Future: Promise-Based Correlation
- Moving toward promise-based patterns (preparation for Resonate)
- Correlation will use promise IDs instead of manual tracking
- Support both patterns during transition
</message-protocol>

<performance>
## Performance Guidelines
- Subprocess creation takes 50-100ms minimum - account for this
- Output streaming latency should be <10ms
- Use flush sentinels for output ordering
- Event-driven patterns reduce CPU usage by >99%
- Session pool should maintain warm sessions to avoid startup delay
- Async wrapper overhead acceptable during transition (< 5ms)
- Target < 5% overhead for local mode Resonate integration
</performance>

<error-handling>
## Error Handling & Cancellation

### Current Cancellation (ThreadedExecutor)
- Two-tier cancellation: cooperative via sys.settrace, hard via worker restart
- Never use dont_inherit=True in compile() - breaks cancellation
- Check cancellation event on each line/call (100 check interval)
- Always allow for cleanup in cooperative cancellation

### Future Cancellation (AsyncExecutor)
- Will use asyncio cancellation for async code
- Resonate will provide durable cancellation tokens
- Must support both patterns during transition

### Input Handling
- Input handling must respond with correct correlation ID
- Future: Will use promise resolution for input responses
</error-handling>

<testing>
## Testing Requirements

### Transition Period Requirements
- Tests may expect AsyncExecutor interface - provide async wrappers
- Both ThreadedExecutor and AsyncExecutor patterns acceptable
- Fix Pydantic validation by providing all required fields
- Handle event loop binding issues in fixtures

### General Requirements
- Default to session reuse in tests (new Session() needs justification)
- Start background tasks explicitly (transport.start(), pool.start())
- Handle InputMessage in execute loops with proper response
- Allow for subprocess startup time (minimum 50-100ms)
- Use fixtures from tests/fixtures/ for consistency
- Ensure event loop consistency in test setup
</testing>

<migration-path>
## Migration Path Considerations

### Phase 1: Foundation Fixes (Current Priority)
- Add async wrappers to ThreadedExecutor for test compatibility
- Fix message protocol field completeness
- Implement namespace merge-only policy
- Fix event loop management

### Phase 2: Bridge Architecture
- Create AsyncExecutor skeleton that delegates to ThreadedExecutor
- Add execution mode routing
- Implement promise abstraction layer
- Create capability base classes

### Phase 3: Full Implementation
- Complete AsyncExecutor with PyCF_ALLOW_TOP_LEVEL_AWAIT
- Integrate Resonate SDK
- Implement durable functions
- Complete capability system

### Review Focus
During transition, prioritize:
1. **Correctness**: Namespace preservation, message completeness
2. **Compatibility**: Support both old and new patterns
3. **Foundation**: Build toward target architecture
4. **Documentation**: Mark temporary vs permanent patterns
</migration-path>

<security>
## Security Considerations
- Never expose or log secrets and keys
- Validate all inputs before execution
- Namespace isolation between executions (merge-only helps here)
- Transaction support for rollback capability
- Source tracking for executed code
- Capability-based security (future) - prepare interfaces
</security>

<documentation>
## Documentation Standards

### Required Documentation
- Document state transitions clearly
- Include timing expectations in comments
- Document lock usage and scope
- Explain event-driven patterns used
- Note any deviation from standard async patterns

### Transition Documentation
- Mark temporary patterns with `# TODO: Temporary until AsyncExecutor`
- Mark future patterns with `# Future: Will use Resonate promises`
- Document which execution mode a code path handles
- Explain namespace merge vs replace decisions

### Code Comments
- Reference spec line numbers for complex implementations
- Link to relevant documentation files
- Explain WHY, not just what (especially for workarounds)
</documentation>

## Review Priorities

When reviewing PRs, prioritize in this order:

1. **Critical Correctness**
   - Namespace never replaced (always merged)
   - Event loop consistency
   - Message protocol completeness

2. **Architectural Alignment**
   - Moving toward AsyncExecutor + Resonate
   - Promise-based patterns over manual correlation
   - Execution mode routing preparation

3. **Test Stability**
   - Tests pass or have clear fix path
   - Event loop issues resolved
   - Async/sync bridge working

4. **Performance**
   - Acceptable transition overhead (< 5%)
   - No polling loops
   - Event-driven patterns

5. **Future Readiness**
   - Interfaces support future patterns
   - Clear migration path
   - Proper abstraction layers