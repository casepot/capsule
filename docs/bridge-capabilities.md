# Bridge & Capabilities

> Status: Authoritative reference for the Resonate bridge and capability wiring (sources referenced at commit `47c9d77602a8f6fb988844df4a8791ad88ebb29d`; if code has drifted, double-check the current sources on your working commit, capture differences that affect your task, and raise any doc gaps to the user while you proceed with up-to-date information).

## Purpose
Capsule’s bridge layer connects the session transport to Resonate’s durable promise APIs so capabilities can be fulfilled without violating the single-reader invariant. The current implementation focuses on local-mode durable execution and human-in-the-loop (HITL) input, wiring a minimal `ResonateProtocolBridge`, capability dependencies, and a `durable_execute` durable function (`src/integration/resonate_bridge.py:24`, `src/integration/resonate_init.py:24`, `src/integration/resonate_functions.py:27`). Provider-specific behavior, registry policy, and additional capability surfaces remain future work; this guide captures what ships today and how upcoming issues will extend it.

## Bridge Lifecycle
**Today** – `initialize_resonate_local` is the entry point that assumes ownership of dependency injection for a session. It instantiates a shared `NamespaceManager`, registers the durable executor function, and binds the session plus bridge into Resonate’s dependency catalog so downstream callable wrappers can resolve them (`src/integration/resonate_init.py:40`, `src/integration/resonate_init.py:43`, `src/integration/resonate_init.py:48`). The initializer also exposes an async-executor factory that reuses the shared namespace manager and defers loop ownership to the existing session event loop, keeping durable functions from spinning their own loops (`src/integration/resonate_init.py:52`, `src/integration/resonate_wrapper.py:23`). Responses are routed back into the bridge via a passive session interceptor that fans out `InputResponse`, `Result`, and `Error` messages using `asyncio.create_task`, ensuring the session remains the sole transport reader (`src/integration/resonate_init.py:74`, `src/session/manager.py:294`). There is no lifecycle API on the bridge; sessions never call `close()` or `cancel_all()`, interceptors are not removed on shutdown, and timeout tasks continue running until each correlation resolves or expires (`src/integration/resonate_bridge.py:48`, `src/integration/resonate_bridge.py:203`).

**Planned (#35)** – BRIDGE-010 will add explicit lifecycle management: idempotent `close()`/`cancel_all()` hooks, structured shutdown rejections, and bridge metrics surfaced through `Session.info().metadata` (#35). The same issue wires those hooks into session shutdown/recycle paths and introduces observability counters for pending correlations and cancellations. BRIDGE-011 builds on this foundation with prioritized routing and interceptor quarantine so cancel traffic is not delayed by capability floods or slow observers (#38).

## Promise Correlation & Timeout Handling
**Today** – `ResonateProtocolBridge.send_request` derives deterministic promise identifiers for each capability. Execute flows reuse the durable promise created by `ctx.promise`, defaulting to `exec:{execution_id}` when the caller does not supply an id, while input requests create a new promise via `input_promise_id(execution_id, input_message.id)` (`src/integration/resonate_bridge.py:77`, `src/integration/constants.py:19`). All requests record a correlation key inside `_pending`, update a local high-water mark, and schedule `_reject_on_timeout` when a positive timeout is provided. When the caller does not request a timeout, the bridge falls back to a 60-second guard so hung correlations eventually reject (`src/integration/resonate_bridge.py:103`, `src/integration/resonate_bridge.py:132`). `route_response` extracts the request id from the protocol payload, atomically removes the pending entry under a lock, cancels any timeout task, and serializes the message back to JSON before resolving or rejecting the durable promise (`src/integration/resonate_bridge.py:142`, `src/integration/resonate_bridge.py:182`). Result and error messages correlate by execution id, while input responses use `input_id`; other capability types would currently fall back to the generic id string stored at send time (`src/integration/resonate_bridge.py:194`). Background timeout tasks remove the pending entry and reject with a structured payload containing capability, execution, and timeout metadata when the deadline elapses (`src/integration/resonate_bridge.py:203`). The bridge exposes a `pending_high_water_mark()` helper for diagnostics but leaves metrics plumbing to future work (`src/integration/resonate_bridge.py:247`).

**Planned (#37, #31)** – PROTO-012 introduces capability request/response message types with idempotency keys and a per-session cache, requiring the bridge to memoize in-flight promises and short-circuit responses when a cached payload is available (#37). PROTO-013 extends correlation rules to streaming channels, so `_extract_correlation_key` will grow to manage stream open/data/close lifecycles alongside execution promises (#31). Both efforts depend on BRIDGE-010 for lifecycle hooks and metrics to remain coherent once more message families share the bridge.

## Durable Execute Integration
**Today** – `register_executor_functions` registers `durable_execute` as a generator-style durable function that embodies the promise-first flow. The function requests a promise id via `ctx.promise`, retrieves the bridge dependency, and sends an `ExecuteMessage` through `bridge.send_request` while capturing optional checkpoints before and after execution (`src/integration/resonate_functions.py:27`, `src/integration/resonate_functions.py:55`). Once the durable promise resolves, it normalizes the payload, raising a structured `RuntimeError` when the payload encodes a protocol error and preserving raw data otherwise (`src/integration/resonate_functions.py:69`, `src/integration/resonate_functions.py:99`). The initializer attaches an `async_executor` factory so future capability wrappers can obtain a fully configured `AsyncExecutor` without managing initialization order, but the current durable_execute path does not instantiate the async executor because execution completes on the worker side (`src/integration/resonate_init.py:52`, `src/integration/resonate_wrapper.py:80`).

**Planned (EW-010, #4)** – EW-010 routes async-aware submissions through `AsyncExecutor`, which will require the bridge to correlate execute promises triggered by the async path and respect the same output-before-result guarantees (#51). FUTURE (#4) tracks worker upgrades to route input responses by execution id instead of the single “active executor” slot, ensuring concurrent capabilities continue to resolve the correct promise once multi-execution sessions are introduced (#4).

## HITL Input Capability
**Today** – `InputCapability.request_input` creates an `InputMessage` with a UUID request id, stamps a 300-second timeout, and forwards it through the bridge. It awaits the returned promise’s `.result()` coroutine and interprets the JSON payload, preferring the modern `data` field while tolerating the historical `input` key for compatibility (`src/integration/capability_input.py:22`, `tests/unit/test_input_capability.py:8`). Invalid JSON is silently converted into an empty string, and rejection payloads raised by the bridge (for timeouts or shutdown) currently bubble up as opaque SDK exceptions because the capability does not perform any structured error mapping (`src/integration/capability_input.py:34`). There are no metrics, audit hooks, or backpressure controls on the capability; callers must enforce their own rate limits.

**Planned (#52)** – CAP-011 upgrades the capability to translate timeout payloads into Python `TimeoutError`, map shutdown rejections to `EOFError`, and attach contextual notes (execution id, request id, timeout) so HITL callers can differentiate operator dismissal from infrastructure failure (#52). The same issue relies on BRIDGE-010’s lifecycle hooks to reject pending promises promptly during session shutdown instead of waiting for the timeout. Additional observability (metrics for timeout vs shutdown) is also tracked there.

## Capability Registry & Policy (Planned)
Capsule does not yet expose a generalized capability registry. Capabilities are attached manually via `resonate.set_dependency("input_capability", ...)`, and wrappers such as `caps.*` namespaces do not exist. CAP-010 will introduce a `CapabilityRegistry`, a deny-by-default security policy, and namespaced injection so only approved capabilities appear inside the execution namespace (#30). That work also depends on new protocol message types from PROTO-012 to encode capability requests, establish idempotency keys, and coordinate authorization decisions. Until those issues ship, input remains the only capability routed through the bridge, and providers should treat the bridge as experimental local-mode infrastructure.

## Known Limitations & Upcoming Work
- Bridge lifecycle lacks cleanup, metrics, and observability; BRIDGE-010 wires these pieces in alongside structured shutdown rejection and telemetry hooks (#35).
- Session routing remains FIFO with synchronous interceptors, so capability floods can delay control traffic; BRIDGE-011 adds priority dispatch and interceptor quarantine (#38).
- Capability requests have no idempotency or registry-level gating, leaving retries and authorization to future work tracked in PROTO-012 and CAP-010 (#37, #30).
- Streaming capabilities, event-driven framing, and richer observability remain roadmap items (PROTO-013, PROTO-010, OBS-011) that will layer additional message types onto the bridge once lifecycle hardening is complete (#31, #39, #41).

## Source References
- `src/integration/resonate_init.py`
- `src/integration/resonate_bridge.py`
- `src/integration/resonate_functions.py`
- `src/integration/capability_input.py`
- `src/integration/resonate_wrapper.py`

## Historical Notes
Legacy prompts describing protocol bridge patterns predate the current promise-centric implementation and should be treated as archival context only (`docs/_legacy/async_capability_prompts/current/21_spec_resonate_integration.md`, `docs/_legacy/async_capability_prompts/current/23_spec_capability_system.md`). Always validate assumptions against the sources cited above before adapting legacy guidance, and port any still-relevant behavior into this document when you encounter it.
