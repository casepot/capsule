name: PR Multi-Model Review (HITL, self-hosted)

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:  # Allow manual trigger for testing

permissions:
  contents: read
  pull-requests: write

jobs:
  review:
    runs-on: self-hosted
    timeout-minutes: 45  # Overall job timeout (providers may take 25+ minutes)
    if: github.event.pull_request.draft == false  # Skip draft PRs
    env:
      # Environment variable overrides (mapped via env.mapping.json)
      TEST_CMD: ${{ vars.TEST_CMD }}                      # Testing command
      REVIEW_TIMEOUT: ${{ vars.REVIEW_TIMEOUT }}          # Global timeout
      CLAUDE_MODEL: ${{ vars.CLAUDE_MODEL }}              # Claude model override
      CODEX_REASONING: ${{ vars.CODEX_REASONING }}        # Codex reasoning level
      GEMINI_MODEL: ${{ vars.GEMINI_MODEL }}              # Gemini model override
      REVIEW_PARALLEL: ${{ vars.REVIEW_PARALLEL }}        # Parallel execution
      GH_TOKEN: ${{ github.token }}                       # GitHub CLI token
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Claude Authentication (OAuth)
        run: |
          # Never use API keys in this pipeline
          unset ANTHROPIC_API_KEY
          # Ensure Claude Code is in PATH if installed in non-standard location
          if [ -x "$HOME/.claude/local/claude" ]; then
            export PATH="$HOME/.claude/local:$PATH"
          fi
          # Quick probe: rely on local OAuth (Keychain)
          if claude -p "echo test" --output-format text >/dev/null 2>&1; then
            echo "âœ“ Claude OAuth available via Keychain"
          else
            echo "::warning::Claude not authenticated. Ensure local '/login' has been completed in the runner user session."
          fi

      - name: Ensure Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Detect PR context (manual runs)
        run: |
          # Populate PR_NUMBER for both PR and manual runs
          if [ -n "${{ github.event.pull_request.number }}" ]; then
            echo "PR_NUMBER=${{ github.event.pull_request.number }}" >> "$GITHUB_ENV"
            echo "Using PR #${{ github.event.pull_request.number }} from event context."
          else
            # Try to find an open PR for this branch
            PR=$(gh pr list --head "${{ github.ref_name }}" --json number -q '.[0].number' || true)
            if [ -n "$PR" ] && [ "$PR" != "null" ]; then
              echo "PR_NUMBER=$PR" >> "$GITHUB_ENV"
              echo "Detected PR #$PR for branch ${{ github.ref_name }}."
            else
              echo "No PR detected for branch ${{ github.ref_name }} (manual run)."
            fi
          fi

      - name: Runner Diagnostics (Claude OAuth)
        run: |
          set -euo pipefail
          echo "whoami: $(whoami)"
          echo "HOME: $HOME"
          # Keychain info (no secrets)
          security show-keychain-info ~/Library/Keychains/login.keychain-db || true
          security find-generic-password -s 'Claude Code-credentials' || true
          # Claude probe (headless)
          if [ -x "$HOME/.claude/local/claude" ]; then export PATH="$HOME/.claude/local:$PATH"; fi
          claude -p "echo test" --output-format text || true

      - name: Guardrails (auth + no API keys + CLIs present)
        run: |
          # Ensure Claude Code is in PATH if installed in non-standard location
          if [ -x "$HOME/.claude/local/claude" ]; then
            export PATH="$HOME/.claude/local:$PATH"
          fi
          # Enforce OAuth-only checks for all providers
          bash .review-pipeline/scripts/auth-check.sh

      - name: Validate configuration
        run: |
          cd .review-pipeline
          npm install --no-audit --no-fund
          node lib/config-loader.js validate || echo "Warning: Configuration validation failed, using defaults"

      - name: Build review context
        shell: bash
        id: context
        run: |
          set -euo pipefail
          mkdir -p .review-pipeline/workspace/context .review-pipeline/workspace/reports
          # PR metadata
          if [ -n "${PR_NUMBER:-}" ]; then
            gh pr view "$PR_NUMBER" --json number,state,headRefName,baseRefName,headRefOid,url,author --repo "${{ github.repository }}" > .review-pipeline/workspace/context/pr.json
          else
            # Manual workflow_dispatch fallback (use jq to construct valid JSON)
            jq -n \
              --arg repo "${{ github.event.repository.name }}" \
              --arg sha "${{ github.sha }}" \
              --arg branch "${{ github.ref_name }}" \
              --arg url "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
              '{repo:$repo, number:0, head_sha:$sha, branch:$branch, link:$url}' \
              > .review-pipeline/workspace/context/pr.json
          fi
          # Diff & files
          if [ -n "${PR_NUMBER:-}" ]; then
            gh pr diff "$PR_NUMBER" --patch --repo "${{ github.repository }}" > .review-pipeline/workspace/context/diff.patch
            gh pr view "$PR_NUMBER" --json files --repo "${{ github.repository }}" | jq -r '.files[].path' > .review-pipeline/workspace/context/files.txt
          else
            # Manual trigger - use git diff
            if git rev-parse -q --verify HEAD~1 >/dev/null 2>&1; then
              git diff HEAD~1 > .review-pipeline/workspace/context/diff.patch || echo "No diff available" > .review-pipeline/workspace/context/diff.patch
              git diff --name-only HEAD~1 > .review-pipeline/workspace/context/files.txt || echo "No files changed" > .review-pipeline/workspace/context/files.txt
            else
              echo "No diff available" > .review-pipeline/workspace/context/diff.patch
              echo "No files changed" > .review-pipeline/workspace/context/files.txt
            fi
          fi

          # Generate annotated hunks with absolute new-file line numbers for precise citations
          node .review-pipeline/scripts/generate-annotated-hunks.js || echo "::warning::Failed to generate annotated hunks"
          # Get test command from configuration or environment
          TEST_CMD="${TEST_CMD:-$(node .review-pipeline/lib/config-loader.js show 2>/dev/null | jq -r '.testing.command // "pytest tests/"' || echo 'pytest tests/')}"
          
          # Optional tests
          if [ -n "${TEST_CMD}" ]; then
            set +e
            echo "\$ ${TEST_CMD}" > .review-pipeline/workspace/context/tests.txt
            timeout 300 bash -c "${TEST_CMD}" >> .review-pipeline/workspace/context/tests.txt 2>&1
            echo "== exit:$? ==" >> .review-pipeline/workspace/context/tests.txt
            set -e
          fi

      - name: Provider reviews (configuration-based)
        shell: bash
        timeout-minutes: 30  # Allow for 25-minute provider timeout plus overhead
        run: |
          set -euo pipefail
          cd .review-pipeline
          
          # Ensure Claude Code is in PATH if installed in non-standard location
          if [ -x "$HOME/.claude/local/claude" ]; then
            export PATH="$HOME/.claude/local:$PATH"
          fi
          
          # Unset any API key envs to prevent metered billing
          unset ANTHROPIC_API_KEY OPENAI_API_KEY GEMINI_API_KEY
          
          # Get configuration settings
          PARALLEL_ENABLED=$(node lib/config-loader.js show 2>/dev/null | jq -r '.execution.parallel // true' || echo 'true')
          GLOBAL_TIMEOUT=$(node lib/config-loader.js show 2>/dev/null | jq -r '.execution.timeout_seconds // 120' || echo '120')
          
          # Get enabled providers
          ENABLED_PROVIDERS=$(node -e "
            import('./lib/config-loader.js').then(async (module) => {
              const ConfigLoader = module.default;
              const loader = new ConfigLoader();
              await loader.load();
              console.log(loader.getEnabledProviders().join(' '));
            }).catch(() => console.log('claude codex gemini'));
          " 2>/dev/null || echo 'claude codex gemini')
          
          echo "Configuration:"
          echo "  Parallel: $PARALLEL_ENABLED"
          echo "  Timeout: $GLOBAL_TIMEOUT seconds"
          echo "  Enabled providers: $ENABLED_PROVIDERS"
          
          # Run provider reviews based on configuration
          run_provider() {
            local provider="$1"
            local timeout="${2:-$GLOBAL_TIMEOUT}"
            
            # Check if provider is enabled
            local enabled=$(node -e "
              import('./lib/config-loader.js').then(async (module) => {
                const ConfigLoader = module.default;
                const loader = new ConfigLoader();
                await loader.load();
                console.log(loader.isProviderEnabled('$provider'));
              }).catch(() => console.log('true'));
            " 2>/dev/null || echo 'true')
            
            if [ "$enabled" != "true" ]; then
              echo "Skipping $provider (disabled)"
              return 0
            fi
            
            # Get provider-specific timeout if configured
            timeout=$(node -e "
              import('./lib/config-loader.js').then(async (module) => {
                const ConfigLoader = module.default;
                const loader = new ConfigLoader();
                await loader.load();
                const config = loader.getProviderConfig('$provider');
                console.log(config.timeout);
              }).catch(() => console.log('$timeout'));
            " 2>/dev/null || echo "$timeout")
            
            echo "Running $provider review (timeout: ${timeout}s)..."
            bash scripts/run-provider-review.sh "$provider" "$timeout" || true
          }
          
          # Execute reviews based on parallel configuration
          if [ "$PARALLEL_ENABLED" = "true" ]; then
            echo "Running reviews in parallel..."
            for provider in $ENABLED_PROVIDERS; do
              run_provider "$provider" &
            done
            wait
          else
            echo "Running reviews sequentially..."
            for provider in $ENABLED_PROVIDERS; do
              run_provider "$provider"
            done
          fi
          
          # Verify reports were created for enabled providers
          for provider in $ENABLED_PROVIDERS; do
            report_file="workspace/reports/${provider}-$([ "$provider" = "claude" ] && echo "code" || echo "cli").json"
            if [ ! -f "$report_file" ]; then
              echo "::warning::Missing report: $report_file"
            fi
          done

      - name: Aggregate & gate
        shell: bash
        run: |
          cd .review-pipeline && npm install --no-audit --no-fund
          node scripts/aggregate-reviews.mjs || echo "Warning: Aggregation had issues, check reports"

      - name: Attach summary as PR comment
        if: always() && (github.event.pull_request.number != '' || env.PR_NUMBER != '')
        shell: bash
        run: |
          if [ -f .review-pipeline/workspace/summary.md ]; then
            # Check if we already commented on this SHA
            PR_NUM="${{ github.event.pull_request.number }}"; if [ -z "$PR_NUM" ]; then PR_NUM="$PR_NUMBER"; fi
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"; if [ -z "$HEAD_SHA" ]; then HEAD_SHA="${{ github.sha }}"; fi
            existing_comments=$(gh pr view "$PR_NUM" --json comments --repo "${{ github.repository }}" | jq -r '.comments[].body' | grep -c "SHA: $HEAD_SHA" || true)
            if [ "$existing_comments" -eq 0 ]; then
              echo "<!-- Multi-Model Review SHA: $HEAD_SHA -->" >> .review-pipeline/workspace/summary.md
              gh pr comment "$PR_NUM" --body-file .review-pipeline/workspace/summary.md --repo "${{ github.repository }}"
            else
              echo "Already commented on this SHA, skipping duplicate."
            fi
          else
            echo "::warning::No summary generated"
          fi

      - name: Fail if gate failed
        shell: bash
        run: |
          if [ -f .review-pipeline/workspace/gate.txt ]; then
            gate_status="$(cat .review-pipeline/workspace/gate.txt)"
            echo "Gate status: $gate_status"
            if [ "$gate_status" = "fail" ]; then
              echo "::error::Review gate failed - must-fix issues found"
              exit 1
            fi
          else
            echo "::warning::No gate status file found"
          fi
